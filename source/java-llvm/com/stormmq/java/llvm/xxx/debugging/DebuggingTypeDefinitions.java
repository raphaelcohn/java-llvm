// The MIT License (MIT)
//
// Copyright Â© 2016, Raphael Cohn <raphael.cohn@stormmq.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package com.stormmq.java.llvm.xxx.debugging;

import com.stormmq.llvm.domain.ReferenceTracker;
import com.stormmq.llvm.domain.target.dataLayout.DataLayoutSpecification;
import com.stormmq.llvm.domain.target.dataLayout.PointerSizing;
import com.stormmq.llvm.metadata.debugging.*;
import com.stormmq.llvm.metadata.debugging.structAlignmentAndSizeCounters.StructAlignmentAndSizeCounter;
import org.jetbrains.annotations.*;

import java.util.*;
import java.util.function.BiConsumer;

import static com.stormmq.functions.ListHelper.newArrayList;
import static com.stormmq.java.parsing.utilities.ReservedIdentifiers.*;
import static com.stormmq.java.parsing.utilities.ReservedIdentifiers._char;
import static com.stormmq.llvm.metadata.debugging.dwarfTags.CompositeDwarfTag.DW_TAG_structure_type;
import static com.stormmq.llvm.metadata.debugging.dwarfTags.DerivedDwarfTag.DW_TAG_const_type;
import static com.stormmq.llvm.metadata.debugging.dwarfTags.BaseDwarfTag.DW_TAG_base_type;
import static com.stormmq.llvm.metadata.debugging.DwarfTypeEncoding.*;
import static com.stormmq.llvm.metadata.debugging.ScopeMetadata.UnknownLineNumber;
import static com.stormmq.llvm.metadata.debugging.structAlignmentAndSizeCounters.StructAlignmentAndSizeCounter.newStructAlignmentAndSizeCounter;
import static com.stormmq.string.Formatting.format;

public final class DebuggingTypeDefinitions<N>
{
	public static final int SixteenBits = 16;
	public static final int ThirtyTwoBits = 32;
	public static final int SixtyFourBits = 64;
	public static final int EightyBits = 80;
	public static final int OneHundredAndTwentyEightBits = 128;

	@NotNull private final DataLayoutSpecification dataLayoutSpecification;
	private final boolean wideCharIsWindows;
	@NotNull private final PointerSizing pointerSizing;
	@NotNull private final ReferenceTracker referenceTracker;
	@NotNull private final DIFileKeyedMetadataTuple file;
	@NotNull private final NamespaceMetadataCreator<N> namespaceMetadataCreator;
	@NotNull private final Map<TypeMetadata, TypeMetadata> knownTypes;

	// Names are those generated by clang from C code
	public DebuggingTypeDefinitions(@NotNull final DataLayoutSpecification dataLayoutSpecification, final boolean wideCharIsWindows, @NotNull final PointerSizing pointerSizing, @NotNull final ReferenceTracker referenceTracker, @NotNull final DIFileKeyedMetadataTuple file, @NotNull final NamespaceMetadataCreator<N> namespaceMetadataCreator)
	{
		this.dataLayoutSpecification = dataLayoutSpecification;
		this.wideCharIsWindows = wideCharIsWindows;
		this.pointerSizing = pointerSizing;
		this.referenceTracker = referenceTracker;
		this.file = file;
		this.namespaceMetadataCreator = namespaceMetadataCreator;
		knownTypes = new HashMap<>(64);
	}

	@NotNull
	public TypeMetadata floatingPoint(final int sizeInBits)
	{
		switch (sizeInBits)
		{
			case ThirtyTwoBits:
				return basicFloat();

			case SixtyFourBits:
				return basicDouble();

			case EightyBits:
			case OneHundredAndTwentyEightBits:
				return basicLongDouble();

			default:
				throw new UnsupportedOperationException(format("Unexpected size in bits '1%s' for floating point", sizeInBits));
		}
	}

	@NotNull
	public TypeMetadata unsignedInteger(final int sizeInBits)
	{
		if (sizeInBits != SixteenBits)
		{
			throw new UnsupportedOperationException(format("Unexpected size in bits '1%s' for unsigned integer", sizeInBits));
		}
		return basicUnsignedShort();
	}

	@NotNull
	public TypeMetadata signedInteger(final int sizeInBits)
	{
		switch (sizeInBits)
		{
			case 1:
				return basicBoolean();

			case 8:
				return basicSignedChar();

			case SixteenBits:
				return basicSignedShort();

			case ThirtyTwoBits:
				return basicSignedInt();

			case SixtyFourBits:
				return basicSignedLongLongInt();

			default:
				throw new UnsupportedOperationException(format("Unexpected size in bits '1%s' for signed integer", sizeInBits));
		}
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicBoolean()
	{
		return basicType("_Bool", 8, dataLayoutSpecification.booleanAlignmentInBits(), DW_ATE_boolean, 'b');
	}
	
	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicChar()
	{
		return basicType(_char, 8, dataLayoutSpecification.byteAlignmentInBits(), DW_ATE_signed_char, 'c');
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedChar()
	{
		return basicType("signed char", 8, dataLayoutSpecification.byteAlignmentInBits(), DW_ATE_signed_char, 'a');
	}
	
	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsignedChar()
	{
		return basicType("unsigned char", 8, dataLayoutSpecification.byteAlignmentInBits(), DW_ATE_unsigned_char, 'h');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicWideChar()
	{
		final int sizeAndAlignment = wideCharIsWindows ? SixteenBits : ThirtyTwoBits;
		return basicSignedIntType("wchar_t", sizeAndAlignment, sizeAndAlignment, 'w');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicChar16()
	{
		return basicType("char16_t", SixteenBits, dataLayoutSpecification.shortAlignmentInBits(), DW_ATE_signed, "Ds");
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicChar32()
	{
		return basicType("char32_t", ThirtyTwoBits, dataLayoutSpecification.intAlignmentInBits(), DW_ATE_signed, "Ds");
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedShort()
	{
		return basicSignedIntType(_short, SixteenBits, SixteenBits, 's');
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicUnsignedShort()
	{
		return basicUnsignedIntType("unsigned short", SixteenBits, dataLayoutSpecification.shortAlignmentInBits(), 't');
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedInt()
	{
		return basicSignedIntType("int", ThirtyTwoBits, dataLayoutSpecification.intAlignmentInBits(), 'i');
	}
	
	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsignedInt()
	{
		return basicUnsignedIntType("unsigned int", ThirtyTwoBits, dataLayoutSpecification.intAlignmentInBits(), 'j');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicSignedLongInt()
	{
		return basicSignedIntType("long int", SixtyFourBits, dataLayoutSpecification.longAlignmentInBits(), 'l');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsignedLongInt()
	{
		return basicUnsignedIntType("long unsigned int", SixtyFourBits, dataLayoutSpecification.longAlignmentInBits(), 'm');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedLongLongInt()
	{
		return basicSignedIntType("long long int", SixtyFourBits, dataLayoutSpecification.longAlignmentInBits(), 'x');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsignedLongLongInt()
	{
		return basicUnsignedIntType("long long unsigned int", SixtyFourBits, dataLayoutSpecification.longAlignmentInBits(), 'y');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicSigned__int128()
	{
		return basicSignedIntType("__int128", OneHundredAndTwentyEightBits, OneHundredAndTwentyEightBits, 'n');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsigned__int128()
	{
		return basicUnsignedIntType("unsigned __int128", OneHundredAndTwentyEightBits, OneHundredAndTwentyEightBits, 'o');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicFloat()
	{
		return basicFloatType(_float, ThirtyTwoBits, dataLayoutSpecification.floatAlignmentInBits(), 'f');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicDouble()
	{
		return basicFloatType(_double, SixtyFourBits, dataLayoutSpecification.doubleAlignmentInBits(), 'd');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicLongDouble()
	{
		// In clang, long double is debugged as 128 bits NOT 80 bits, even on x86; see also https://stackoverflow.com/questions/13525774/clang-and-float128-bug-error/17056045
		return basicFloatType("long double", OneHundredAndTwentyEightBits, dataLayoutSpecification.longDoubleAlignmentInBits(), 'e');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedIntType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInButs, final char itaniumAbiNameManglingCode)
	{
		return basicType(name, sizeInBits, alignmentInButs, DW_ATE_signed, itaniumAbiNameManglingCode);
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicUnsignedIntType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInBits, final char itaniumAbiNameManglingCode)
	{
		return basicType(name, sizeInBits, alignmentInBits, DW_ATE_unsigned, itaniumAbiNameManglingCode);
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicFloatType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInBits, final char itaniumAbiNameManglingCode)
	{
		return basicType(name, sizeInBits, alignmentInBits, DW_ATE_float, itaniumAbiNameManglingCode);
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInBits, @NotNull final DwarfTypeEncoding encoding, final char itaniumAbiNameManglingCode)
	{
		return basicType(name, sizeInBits, alignmentInBits, encoding, String.valueOf(itaniumAbiNameManglingCode));
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInBits, @NotNull final DwarfTypeEncoding encoding, @NotNull @NonNls final String itaniumAbiNameManglingCode)
	{
		final DIBasicTypeKeyedMetadataTuple diBasicTypeKeyedMetadataTuple = new DIBasicTypeKeyedMetadataTuple(referenceTracker, DW_TAG_base_type, name, sizeInBits, alignmentInBits, encoding);
		return (DIBasicTypeKeyedMetadataTuple) knownTypes.computeIfAbsent(diBasicTypeKeyedMetadataTuple, typeMetadata -> diBasicTypeKeyedMetadataTuple);
	}

	@NotNull
	public DIDerivedTypeKeyedMetadataTuple constantDerivedType(@NotNull final DIBasicTypeKeyedMetadataTuple baseType)
	{
		final DIDerivedTypeKeyedMetadataTuple diDerivedTypeKeyedMetadataTuple = new DIDerivedTypeKeyedMetadataTuple(referenceTracker, DW_TAG_const_type, baseType, pointerSizing);
		return (DIDerivedTypeKeyedMetadataTuple) knownTypes.computeIfAbsent(diDerivedTypeKeyedMetadataTuple, typeMetadata -> diDerivedTypeKeyedMetadataTuple);
	}

	@NotNull
	public DIDerivedTypeKeyedMetadataTuple constantDerivedType(@NotNull final TypeMetadata baseType)
	{
		if (baseType instanceof DIBasicTypeKeyedMetadataTuple)
		{
			return constantDerivedType((DIBasicTypeKeyedMetadataTuple) baseType);
		}
		if (baseType instanceof DIDerivedTypeKeyedMetadataTuple)
		{
			if (((DIDerivedTypeKeyedMetadataTuple) baseType).isConstType())
			{
				return (DIDerivedTypeKeyedMetadataTuple) baseType;
			}
		}
		final DIDerivedTypeKeyedMetadataTuple diDerivedTypeKeyedMetadataTuple = new DIDerivedTypeKeyedMetadataTuple(referenceTracker, DW_TAG_const_type, baseType, pointerSizing);
		return (DIDerivedTypeKeyedMetadataTuple) knownTypes.computeIfAbsent(diDerivedTypeKeyedMetadataTuple, typeMetadata -> diDerivedTypeKeyedMetadataTuple);
	}

	// eg KnownReferenceTypeName.simpleTypeName()/.parent()
	@NotNull
	public DICompositeTypeKeyedMetadataTuple compositeType(@NotNull final N namespace, @NotNull @NonNls final String simpleName, @NotNull final Map<String, TypeMetadata> fields, final boolean isPacked)
	{
		final StructAlignmentAndSizeCounter structAlignmentAndSizeCounter = newStructAlignmentAndSizeCounter(isPacked);
		final List<DIDerivedTypeKeyedMetadataTuple> elements = newArrayList(fields.size(), list ->
		{
			fields.forEach(new BiConsumer<String, TypeMetadata>()
			{
				private int offsetInBits = 0;

				@Override
				public void accept(final String fieldName, final TypeMetadata fieldTypeMetadata)
				{
					// scope is a reference to the composite type. yuck.
					final DIDerivedTypeKeyedMetadataTuple element = new DIDerivedTypeKeyedMetadataTuple(referenceTracker, file, UnknownLineNumber, fieldTypeMetadata, pointerSizing, fieldName, offsetInBits);
					list.add(element);
					structAlignmentAndSizeCounter.accept(element);
					offsetInBits = structAlignmentAndSizeCounter.currentOffsetInBits();
				}
			});
		});
		final int sizeInBits = structAlignmentAndSizeCounter.sizeInBits();
		final int alignmentInBits = structAlignmentAndSizeCounter.alignmentInBits();
		
		// We do not yet support vtableHolder: !"_ZTSN3com7stormmq11inheritance13HasAnnotationE"

		final DINamespaceKeyedMetadataTuple diNamespaceKeyedMetadataTuple = namespaceMetadataCreator.namespace(namespace);
		final String identifier = namespaceMetadataCreator.identifier(namespace, simpleName);

		final DICompositeTypeKeyedMetadataTuple diCompositeTypeKeyedMetadataTuple = new DICompositeTypeKeyedMetadataTuple(referenceTracker, isPacked, DW_TAG_structure_type, simpleName, diNamespaceKeyedMetadataTuple, file, UnknownLineNumber, sizeInBits, alignmentInBits, identifier, elements);
		elements.forEach(element -> element.populateScope(diCompositeTypeKeyedMetadataTuple));
		return diCompositeTypeKeyedMetadataTuple;
	}
}
