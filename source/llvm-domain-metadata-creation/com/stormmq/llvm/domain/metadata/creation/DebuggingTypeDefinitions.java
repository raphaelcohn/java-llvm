// The MIT License (MIT)
//
// Copyright Â© 2016, Raphael Cohn <raphael.cohn@stormmq.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package com.stormmq.llvm.domain.metadata.creation;

import com.stormmq.functions.SizedIterator;
import com.stormmq.llvm.domain.ReferenceTracker;
import com.stormmq.llvm.domain.target.dataLayout.DataLayoutSpecification;
import com.stormmq.llvm.domain.target.dataLayout.PointerSizing;
import com.stormmq.llvm.domain.metadata.debugging.*;
import com.stormmq.string.StringConstants;
import org.jetbrains.annotations.*;

import java.util.*;
import java.util.Map.Entry;

import static com.stormmq.llvm.domain.metadata.debugging.DIDerivedTypeKeyedMetadataTuple.constant;
import static com.stormmq.string.StringConstants._char;
import static com.stormmq.llvm.domain.target.dataLayout.DataLayoutSpecification.*;
import static com.stormmq.llvm.domain.metadata.debugging.dwarfTags.BaseDwarfTag.DW_TAG_base_type;
import static com.stormmq.llvm.domain.metadata.debugging.DwarfTypeEncoding.*;
import static com.stormmq.llvm.domain.metadata.debugging.ScopeMetadata.UnknownLineNumber;
import static com.stormmq.string.Formatting.format;

public final class DebuggingTypeDefinitions<N>
{
	@NotNull private final DataLayoutSpecification dataLayoutSpecification;
	@NotNull private final ReferenceTracker referenceTracker;
	@NotNull private final DIFileKeyedMetadataTuple file;
	@NotNull private final NamespaceSplitter<N> namespaceSplitter;
	@NotNull private final PointerSizing pointerSizing;
	@NotNull private final Map<String, TypeMetadata> knownBasicTypes;
	@NotNull private final Map<TypeMetadata, DIDerivedTypeKeyedMetadataTuple> knownConstantTypes;
	@NotNull private final Map<String, DICompositeTypeKeyedMetadataTuple> knownStructureTypes;

	// Names are those generated by clang from C code
	public DebuggingTypeDefinitions(@NotNull final DataLayoutSpecification dataLayoutSpecification, @NotNull final ReferenceTracker referenceTracker, @NotNull final DIFileKeyedMetadataTuple file, @NotNull final NamespaceSplitter<N> namespaceSplitter)
	{
		this.dataLayoutSpecification = dataLayoutSpecification;
		this.referenceTracker = referenceTracker;
		this.file = file;
		this.namespaceSplitter = namespaceSplitter;
		pointerSizing = dataLayoutSpecification.globalAddressSpacePointerSizing();
		knownBasicTypes = new HashMap<>(32);
		knownConstantTypes = new HashMap<>(128);
		knownStructureTypes = new HashMap<>(64);
	}

	@NotNull
	public TypeMetadata floatingPoint(final int sizeInBits)
	{
		switch (sizeInBits)
		{
			case ThirtyTwoBits:
				return basicFloat();

			case SixtyFourBits:
				return basicDouble();

			case EightyBits:
			case OneHundredAndTwentyEightBits:
				return basicLongDouble();

			default:
				throw new UnsupportedOperationException(format("Unexpected size in bits '1%s' for floating point", sizeInBits));
		}
	}

	@NotNull
	public TypeMetadata unsignedInteger(final int sizeInBits)
	{
		if (sizeInBits != SixteenBits)
		{
			throw new UnsupportedOperationException(format("Unexpected size in bits '1%s' for unsigned integer", sizeInBits));
		}
		return basicUnsignedShort();
	}

	@NotNull
	public TypeMetadata signedInteger(final int sizeInBits)
	{
		switch (sizeInBits)
		{
			case 1:
				return basicBoolean();

			case 8:
				return basicSignedChar();

			case SixteenBits:
				return basicSignedShort();

			case ThirtyTwoBits:
				return basicSignedInt();

			case SixtyFourBits:
				return basicSignedLongLongInt();

			default:
				throw new UnsupportedOperationException(format("Unexpected size in bits '1%s' for signed integer", sizeInBits));
		}
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicBoolean()
	{
		return basicType("_Bool", dataLayoutSpecification.booleanSizeInBitsRoundedUpToNearestEightBits(), dataLayoutSpecification.booleanAlignmentInBits(), DW_ATE_boolean, 'b');
	}
	
	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicChar()
	{
		return basicType(_char, dataLayoutSpecification.byteSizeInBits(), dataLayoutSpecification.byteAlignmentInBits(), DW_ATE_signed_char, 'c');
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedChar()
	{
		return basicType("signed char", dataLayoutSpecification.byteSizeInBits(), dataLayoutSpecification.byteAlignmentInBits(), DW_ATE_signed_char, 'a');
	}
	
	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsignedChar()
	{
		return basicType("unsigned char", dataLayoutSpecification.byteSizeInBits(), dataLayoutSpecification.byteAlignmentInBits(), DW_ATE_unsigned_char, 'h');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicWideChar()
	{
		return basicSignedIntType("wchar_t", dataLayoutSpecification.wideCharSizeInBits(), dataLayoutSpecification.wideCharAlignmentInBits(), 'w');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicChar16()
	{
		return basicType("char16_t", dataLayoutSpecification.shortSizeInBits(), dataLayoutSpecification.shortAlignmentInBits(), DW_ATE_signed, "Ds");
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicChar32()
	{
		return basicType("char32_t", dataLayoutSpecification.intSizeInBits(), dataLayoutSpecification.intAlignmentInBits(), DW_ATE_signed, "Di");
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedShort()
	{
		return basicSignedIntType(StringConstants._short, dataLayoutSpecification.shortSizeInBits(), SixteenBits, 's');
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicUnsignedShort()
	{
		return basicUnsignedIntType("unsigned short", dataLayoutSpecification.shortSizeInBits(), dataLayoutSpecification.shortAlignmentInBits(), 't');
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedInt()
	{
		return basicSignedIntType("int", dataLayoutSpecification.intSizeInBits(), dataLayoutSpecification.intAlignmentInBits(), 'i');
	}
	
	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsignedInt()
	{
		return basicUnsignedIntType("unsigned int", dataLayoutSpecification.intSizeInBits(), dataLayoutSpecification.intAlignmentInBits(), 'j');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicSignedLongInt()
	{
		return basicSignedIntType("long int", SixtyFourBits, dataLayoutSpecification.longAlignmentInBits(), 'l');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsignedLongInt()
	{
		return basicUnsignedIntType("long unsigned int", SixtyFourBits, dataLayoutSpecification.longAlignmentInBits(), 'm');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedLongLongInt()
	{
		return basicSignedIntType("long long int", SixtyFourBits, dataLayoutSpecification.longAlignmentInBits(), 'x');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsignedLongLongInt()
	{
		return basicUnsignedIntType("long long unsigned int", SixtyFourBits, dataLayoutSpecification.longAlignmentInBits(), 'y');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicSigned__int128()
	{
		return basicSignedIntType("__int128", dataLayoutSpecification.int128SizeInBits(), dataLayoutSpecification.int128AlignmentInBits(), 'n');
	}

	@NotNull
	public DIBasicTypeKeyedMetadataTuple basicUnsigned__int128()
	{
		return basicUnsignedIntType("unsigned __int128", dataLayoutSpecification.int128SizeInBits(), dataLayoutSpecification.int128AlignmentInBits(), 'o');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicFloat()
	{
		return basicFloatType(StringConstants._float, dataLayoutSpecification.floatSizeInBits(), dataLayoutSpecification.floatAlignmentInBits(), 'f');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicDouble()
	{
		return basicFloatType(StringConstants._double, dataLayoutSpecification.doubleSizeInBits(), dataLayoutSpecification.doubleAlignmentInBits(), 'd');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicLongDouble()
	{
		return basicFloatType("long double", dataLayoutSpecification.longDoubleSizeInBits(), dataLayoutSpecification.longDoubleAlignmentInBits(), 'e');
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicSignedIntType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInButs, final char itaniumAbiNameManglingCode)
	{
		return basicType(name, sizeInBits, alignmentInButs, DW_ATE_signed, itaniumAbiNameManglingCode);
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicUnsignedIntType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInBits, final char itaniumAbiNameManglingCode)
	{
		return basicType(name, sizeInBits, alignmentInBits, DW_ATE_unsigned, itaniumAbiNameManglingCode);
	}
	
	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicFloatType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInBits, final char itaniumAbiNameManglingCode)
	{
		return basicType(name, sizeInBits, alignmentInBits, DW_ATE_float, itaniumAbiNameManglingCode);
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInBits, @NotNull final DwarfTypeEncoding encoding, final char itaniumAbiNameManglingCode)
	{
		return basicType(name, sizeInBits, alignmentInBits, encoding, String.valueOf(itaniumAbiNameManglingCode));
	}

	@NotNull
	private DIBasicTypeKeyedMetadataTuple basicType(@NonNls @NotNull final String name, final int sizeInBits, final int alignmentInBits, @NotNull final DwarfTypeEncoding encoding, @NotNull @NonNls final String itaniumAbiNameManglingCode)
	{
		return (DIBasicTypeKeyedMetadataTuple) knownBasicTypes.computeIfAbsent(name, typeMetadata -> new DIBasicTypeKeyedMetadataTuple(referenceTracker, name, sizeInBits, alignmentInBits, encoding));
	}
	@NotNull
	public DIDerivedTypeKeyedMetadataTuple fieldConstantDerivedType(@NotNull final TypeMetadata baseType)
	{
		if (baseType instanceof DIBasicTypeKeyedMetadataTuple)
		{
			return fieldConstantDerivedType((DIBasicTypeKeyedMetadataTuple) baseType, file);
		}
		if (baseType instanceof DIDerivedTypeKeyedMetadataTuple)
		{
			if (((DIDerivedTypeKeyedMetadataTuple) baseType).isConstType())
			{
				return (DIDerivedTypeKeyedMetadataTuple) baseType;
			}
		}
		final DIDerivedTypeKeyedMetadataTuple diDerivedTypeKeyedMetadataTuple = constant(referenceTracker, file, UnknownLineNumber, baseType, pointerSizing);
		return knownConstantTypes.computeIfAbsent(baseType, typeMetadata -> diDerivedTypeKeyedMetadataTuple);
	}

	@NotNull
	private DIDerivedTypeKeyedMetadataTuple fieldConstantDerivedType(@NotNull final DIBasicTypeKeyedMetadataTuple baseType, @NotNull final DIFileKeyedMetadataTuple file)
	{
		final DIDerivedTypeKeyedMetadataTuple diDerivedTypeKeyedMetadataTuple = constant(referenceTracker, file, UnknownLineNumber, baseType, pointerSizing);
		return knownConstantTypes.computeIfAbsent(baseType, typeMetadata -> diDerivedTypeKeyedMetadataTuple);
	}


	@NotNull
	public DICompositeTypeKeyedMetadataTuple structureType(@NotNull final NamespacedTypeName<N> namespacedTypeName, final boolean isPacked, @NotNull final SizedIterator<Entry<String, TypeMetadata>> fields)
	{
		final String identifier = namespacedTypeName.mangleIdentifier(namespaceSplitter);

		// Will work, even for size calculations, as long as struct A => pointer to struct B
		@Nullable final DICompositeTypeKeyedMetadataTuple existingButPossiblyUnpopulated = knownStructureTypes.get(identifier);
		if (existingButPossiblyUnpopulated != null)
		{
			return existingButPossiblyUnpopulated;
		}

		// Has to be put BEFORE populated in case of nested circular references of struct A => refers to struct B => refers to struct A
		final DICompositeTypeKeyedMetadataTuple unpopulatedCircularReference = new DICompositeTypeKeyedMetadataTuple(referenceTracker);
		knownStructureTypes.put(identifier, unpopulatedCircularReference);

		final DINamespaceKeyedMetadataTuple diNamespaceKeyedMetadataTuple = namespacedTypeName.createDebuggingNamespace(referenceTracker, file, namespaceSplitter);
		return unpopulatedCircularReference.populateStructure(namespacedTypeName.simpleName, diNamespaceKeyedMetadataTuple, file, UnknownLineNumber, identifier, pointerSizing, isPacked, fields);
	}

}
